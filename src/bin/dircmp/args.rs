#[derive(Debug, thiserror::Error)]
enum Error {
    #[error("Path does not exist")]
    PathDoesNotExist,
    #[error("Path is not a directory")]
    PathNotDir,
    #[error("Could not create file: {0}")]
    Create(std::io::Error),
    #[error("Could not open file: {0}")]
    Open(std::io::Error),
}

pub fn parse() -> Option<Command> {
    <App as clap::Parser>::parse().cli
}

#[derive(Debug, clap::Parser)]
struct App {
    #[command(subcommand)]
    pub cli: Option<Command>,
}

#[derive(Debug, clap::Subcommand)]
pub enum Command {
    Scan(Scan),
    Print(Print),
}

impl Command {
    pub fn verbosity(&self) -> log::LevelFilter {
        match self {
            Command::Scan(Scan { verbosity, .. }) | Command::Print(Print { verbosity, .. }) => {
                to_verbosity(*verbosity)
            }
        }
    }
}

#[derive(Debug, clap::Args)]
pub struct Scan {
    /// Verbosity level
    #[arg(short, global = true, action = clap::ArgAction::Count)]
    pub verbosity: u8,
    /// Show matched items
    #[arg(short, long, default_value = "diff")]
    pub print: PrintFilter,
    /// Path to the `left` directory to compare
    #[arg(value_parser = clap::builder::TypedValueParser::try_map(clap::builder::OsStringValueParser::new(), parse_dir))]
    pub left: std::path::PathBuf,
    /// Path to the `right` directory to compare
    #[arg(value_parser = clap::builder::TypedValueParser::try_map(clap::builder::OsStringValueParser::new(), parse_dir))]
    pub right: std::path::PathBuf,
    /// Path to write results to
    #[arg(short, long, required_if_eq("print", "none"), value_parser = clap::builder::TypedValueParser::try_map(clap::builder::OsStringValueParser::new(), to_write_file))]
    pub output: Option<std::sync::Arc<std::fs::File>>,
    /// Path to write the TSV summary to
    #[arg(short, long, value_parser = clap::builder::TypedValueParser::try_map(clap::builder::OsStringValueParser::new(), to_write_file))]
    pub summary: Option<std::sync::Arc<std::fs::File>>,
}

#[derive(Debug, clap::Args)]
pub struct Print {
    /// Verbosity level
    #[arg(short, global = true, action = clap::ArgAction::Count)]
    pub verbosity: u8,
    /// Show matched items
    #[arg(short, long)]
    pub matched: bool,
    /// Path to the results file generated by the `scan` command
    #[arg(value_parser = clap::builder::TypedValueParser::try_map(clap::builder::OsStringValueParser::new(), to_read_file))]
    pub input: std::sync::Arc<std::fs::File>,
    /// Path to write the TSV summary to
    #[arg(short, long, value_parser = clap::builder::TypedValueParser::try_map(clap::builder::OsStringValueParser::new(), to_write_file))]
    pub summary: Option<std::sync::Arc<std::fs::File>>,
}

#[derive(Copy, Clone, Eq, PartialEq, Debug, clap::ValueEnum)]
pub enum PrintFilter {
    None,
    Diff,
    All,
}

fn parse_dir(input: std::ffi::OsString) -> Result<std::path::PathBuf, Error> {
    let path = std::path::PathBuf::from(input);

    if !path.exists() {
        Err(Error::PathDoesNotExist)
    } else if !path.is_dir() {
        Err(Error::PathNotDir)
    } else {
        Ok(path)
    }
}

fn to_write_file(input: std::ffi::OsString) -> Result<std::sync::Arc<std::fs::File>, Error> {
    std::fs::File::create(input)
        .map_err(Error::Create)
        .map(std::sync::Arc::new)
}

fn to_read_file(input: std::ffi::OsString) -> Result<std::sync::Arc<std::fs::File>, Error> {
    std::fs::File::open(input)
        .map_err(Error::Open)
        .map(std::sync::Arc::new)
}

fn to_verbosity(value: u8) -> log::LevelFilter {
    match value {
        0 => log::LevelFilter::Error,
        1 => log::LevelFilter::Warn,
        2 => log::LevelFilter::Info,
        3 => log::LevelFilter::Debug,
        _ => log::LevelFilter::Trace,
    }
}
